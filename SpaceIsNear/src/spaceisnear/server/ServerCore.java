// Generated by delombok at Sun Dec 01 13:28:22 MSK 2013
/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package spaceisnear.server;

import java.io.IOException;
import org.newdawn.slick.Image;
import spaceisnear.game.layer.TiledLayer;
import spaceisnear.server.objects.GameObject;
import spaceisnear.server.objects.Player;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.newdawn.slick.SlickException;
import spaceisnear.game.components.Component;
import spaceisnear.game.components.HealthComponent;
import spaceisnear.game.layer.ObstaclesLayer;
import spaceisnear.game.messages.MessageDied;
import spaceisnear.game.messages.MessageKnockbacked;
import spaceisnear.game.messages.MessagePaused;
import spaceisnear.game.messages.MessageToSend;
import spaceisnear.game.messages.MessageUnpaused;

/**
 * @author white_oak
 */
public class ServerCore implements Runnable {

    private final GameContext context;
    private final boolean unbreakable = true;
    private boolean paused = false;
    private static final int QUANT_TIME = 20;
    private boolean alreadyPaused;
    private TiledLayer tiledLayer;
    public static final int OBJECTS_TO_SKIP = 1;

    public ServerCore() {

	//<editor-fold defaultstate="collapsed" desc="map generating">
	try {
	    tiledLayer = new TiledLayer(new Image(getClass().getResourceAsStream("/res/tiles1.png"), "sprites", false),
		    spaceisnear.game.GameContext.TILE_WIDTH, spaceisnear.game.GameContext.TILE_HEIGHT, 128, 128);
	    //tiledLayer.fillRectTile(0, 0, 128, 128, 1);
	    //tiledLayer.fillRectTile(64, 0, 64, 128, 2);
	    tiledLayer.fillRectTile(0, 0, 128, 128, 5);
	    Random rnd = new Random();
	    for (int i = 0; i < 5; i++) {
		int blockx = rnd.nextInt(124);
		int blocky = rnd.nextInt(124);
		tiledLayer.setTile(blockx, blocky, 7);
		tiledLayer.setTile(blockx + 1, blocky, 8);
		tiledLayer.setTile(blockx, blocky + 1, 9);
		tiledLayer.setTile(blockx + 1, blocky + 1, 10);
	    }
	} catch (SlickException ex) {
	    Logger.getLogger(ServerCore.class.getName()).log(Level.SEVERE, null, ex);
	}
	//</editor-fold>
	final ArrayList<GameObject> objects = new ArrayList<>();
	for (int i = 0; i < OBJECTS_TO_SKIP; i++) {
	    objects.add(null);
	}
	context = new GameContext(new Networking(this), objects, tiledLayer);
    }

    @Override
    public void run() {
	while (unbreakable) {
	    if (!paused) {
		for (GameObject gameObject : getContext().getObjects()) {
		    if (gameObject != null) {
			gameObject.process();
		    }
		}
		for (Player player : getContext().getPlayers()) {
		    HealthComponent hc = player.getHealthComponent();
		    switch (hc.getState()) {
			case CRITICICAL:
			    MessageKnockbacked messageKnockbacked = new MessageKnockbacked();
			    getContext().sendToID(messageKnockbacked, player.getId());
			    getContext().sendToID(new MessageToSend(messageKnockbacked), player.getId());
			    break;

			case DEAD:
			    MessageDied messageDied = new MessageDied();
			    getContext().sendToID(messageDied, player.getId());
			    getContext().sendToID(new MessageToSend(messageDied), player.getId());
			    break;

		    }
		}
	    } else {
		if (!alreadyPaused) {
		    alreadyPaused = true;
		}
	    }
	    try {
		Thread.sleep(QUANT_TIME);
	    } catch (InterruptedException ex) {
		Logger.getLogger(ServerCore.class.getName()).log(Level.SEVERE, null, ex);
	    }
	}
    }

    public void pause() {
	paused = true;
	context.getNetworking().sendToAll(new MessagePaused());
	System.out.println("Server\'s been paused");
    }

    public void unpause() {
	context.getNetworking().sendToAll(new MessageUnpaused());
	paused = false;
	alreadyPaused = false;
    }

    public void host() throws IOException {
	getContext().getNetworking().host();
    }

    public Player addPlayer(int connectionID) {
	return context.addPlayer(connectionID);
    }

    GameContext getContext() {
	return this.context;
    }

    public boolean isAlreadyPaused() {
	return this.alreadyPaused;
    }

    public TiledLayer getTiledLayer() {
	return this.tiledLayer;
    }
}
