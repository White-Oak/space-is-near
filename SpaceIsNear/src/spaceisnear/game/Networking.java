// Generated by delombok at Sun Dec 01 13:28:22 MSK 2013
package spaceisnear.game;

import com.esotericsoftware.kryonet.*;
import com.google.gson.JsonSyntaxException;
import java.io.IOException;
import spaceisnear.LoadingScreen;
import spaceisnear.game.bundles.*;
import spaceisnear.game.messages.*;
import spaceisnear.game.messages.properties.MessageNicknameSet;
import spaceisnear.game.messages.properties.MessageYourPlayerDiscovered;
import spaceisnear.game.messages.service.MessageNetworkState;
import spaceisnear.game.messages.service.MessageRogered;
import spaceisnear.game.messages.service.onceused.MessageClientInformation;
import spaceisnear.game.messages.service.onceused.MessageWorldInformation;
import spaceisnear.game.objects.*;
import spaceisnear.game.objects.items.ItemsArchive;
import spaceisnear.game.objects.items.StaticItem;
import spaceisnear.server.Registerer;

/**
 * @author LPzhelud
 */
public class Networking extends Listener {

    private final GameContext gameContext;
    private Client client;
    private final static MessageRogered ROGERED = new MessageRogered();

    public void connect(String host, int tcpPort) throws IOException {
	client = new Client(256 * 1024, 1024);
	Registerer.registerEverything(client);
	client.start();
	client.addListener(this);
	client.connect(5000, host, tcpPort);
//	send(new MessageClientInformation(Menu.nickname.getText()));
	send(new MessageClientInformation("lol"));
    }

    public void send(NetworkableMessage message) {
	Bundle bundle = message.getBundle();
	if (client != null && client.isConnected()) {
	    client.sendTCP(bundle);
	}
//	System.out.println("Message sent");
    }

    @Override
    public void connected(Connection connection) {
	connection.sendTCP("Got it");
	gameContext.sendThemAll(new MessageNetworkState(1));
    }

    @Override
    public void disconnected(Connection connection) {
	gameContext.sendThemAll(new MessageNetworkState(2));
    }

    @Override
    public void idle(Connection connection) {
	gameContext.sendThemAll(new MessageNetworkState(3));
    }

    @Override
    public void received(Connection connection, Object object) {
	if (object instanceof MessageBundle) {
	    MessageBundle bundle = (MessageBundle) object;
	    MessageType mt = bundle.messageType;
	    byte[] b = bundle.bytes;
	    switch (mt) {
		case MOVED:
		    MessageMoved mm = MessageMoved.getInstance(b);
		    processMessageMoved(mm);
		    break;
		case PAUSED:
		    processMessagePaused();
		    break;
		case UNPAUSED:
		    processMessageUnpaused();
		    break;
		case DIED:
		    processMessageDied();
		    break;
		case DISCOVERED_PLAYER:
		    MessageYourPlayerDiscovered dypm = MessageYourPlayerDiscovered.getInstance(b);
		    processDiscoveredYourPlayerMessage(dypm);
		    break;
		case ROGER_REQUESTED:
		    send(ROGERED);
		    break;
		case CREATED_SIMPLIFIED:
		    MessageCreated mc = MessageCreated.getInstance(b);
		    processMessageCreated(mc);
		    break;
		case CREATED_SIMPLIFIED_ITEM:
		    MessageCreatedItem mci = MessageCreatedItem.getInstance(b);
		    processMessageCreatedItem(mci);
		    break;
		case WORLD_INFO:
		    MessageWorldInformation mwi = MessageWorldInformation.getInstance(b);
		    processMessageWorldInformation(mwi);
		    break;
		case LOG:
		    MessageLog ml = MessageLog.getInstance(b);
		    gameContext.getCore().log(ml.getLog());
		    break;
		case TELEPORTED:
		    MessageTeleported mte = MessageTeleported.getInstance(b);
		    gameContext.sendToID(mte, mte.getId());
		    break;
		case NICKNAME_SET:
		    MessageNicknameSet mns = MessageNicknameSet.getInstance(b);
		    processMessageNicknameSet(mns);
		    break;
		case INVENTORY_SET:
		    MessageInventorySet mis = MessageInventorySet.getInstance(b);
		    GamerPlayer player = gameContext.getPlayer();
		    player.getInventoryComponent().setSlots(mis.getSet());
		    break;
	    }
//	    System.out.println("Message received");
//	    gameContext.getCore().log(new LogString("Message received", LogLevel.DEBUG));
	}
    }

    private void processMessageNicknameSet(MessageNicknameSet mns) {
	GamerPlayer player = gameContext.getPlayer();
	player.setNickname(mns.getNickname());
    }

    private void processMessageWorldInformation(MessageWorldInformation mwi) {
	LoadingScreen.LOADING_AMOUNT = mwi.amountOfItems;
	LoadingScreen.CURRENT_AMOUNT = 0;
    }

    private void processMessageCreatedItem(MessageCreatedItem mci) {
	StaticItem item = ItemsArchive.itemsArchive.getNewItem(mci.getId(), gameContext);
	if (item != null) {
	    gameContext.addObject(item);
	    LoadingScreen.CURRENT_AMOUNT++;
	}
    }

    private void processDiscoveredYourPlayerMessage(MessageYourPlayerDiscovered dypm) {
	gameContext.setNewGamerPlayer(dypm.getPlayerID());
    }

    private void processMessageMoved(MessageMoved mm) {
	gameContext.sendToID(mm, mm.getId());
    }

    private void processMessagePaused() {
	gameContext.getCore().pause();
    }

    private void processMessageCreated(MessageCreated mc) throws JsonSyntaxException {
	ClientGameObject gameObject = null;
	switch (mc.getType()) {
	    case PLAYER:
		gameObject = new Player(gameContext);
		break;
	}
	if (gameObject != null) {
	    gameContext.addObject(gameObject);
	    LoadingScreen.CURRENT_AMOUNT++;
	}
    }

    private void processMessageUnpaused() {
	gameContext.getCore().unpause();
    }

    private void processMessageDied() {
    }

    public void close() {
	if (client != null) {
	    client.close();
	}
    }

    @java.beans.ConstructorProperties({"gameContext"})
    public Networking(final GameContext gameContext) {

	this.gameContext = gameContext;
    }

}
